"""Converts data to TFRecords file format with Example protos.
images are resized to have the shortest side be 256.

Requires the rijksgt.json as generated by matlabeler.py
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import os, random
import json
from random import shuffle, seed
import string
import tensorflow as tf
import numpy as np

from scipy import misc
from scipy.misc import imread, imresize
from skimage import color
from collections import Counter
from sklearn.model_selection import train_test_split
import matplotlib
matplotlib.use('Agg')

tf.app.flags.DEFINE_string('images_root', '/fastdata/vangogh/resized',
                           'Location where original images are stored')
tf.app.flags.DEFINE_string('directory', '/fastdata/vangogh/tfrecords',
                           'Directory to write the converted result to')
tf.app.flags.DEFINE_string('input_json', '/fastdata/vangogh/vg_wikipedia.json',
                           'Input CSV to process')
tf.app.flags.DEFINE_string('exclude', '/fastdata/vangogh/wiki_excluded.json',
                           'Input CSV to process')

FLAGS = tf.app.flags.FLAGS

def _int64_feature(value):
    return tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))

def _int64_features(value):
    return tf.train.Feature(int64_list=tf.train.Int64List(value=value))

def _bytes_feature(value):
    return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))

def _bytes_features(value):
    return tf.train.Feature(bytes_list=tf.train.BytesList(value=value))

def write_to(writer, filename, period, ix, shortest_side=256, LAB=True):
    image_raw = misc.imread(filename)

    height = image_raw.shape[0] 
    width = image_raw.shape[1]

    if len(image_raw.shape) < 3:
        image_raw = np.tile(np.reshape(image_raw, [height, width, 1]), [1,1,3])

    if height > shortest_side or width > shortest_side:
        if height < width:
            new_height = shortest_side
            new_width = round(width * (new_height/height))
        else:
            new_width = shortest_side
            new_height = round(height * (new_width/width))
        image_raw = misc.imresize(image_raw, (int(new_height), int(new_width)), interp='bicubic')
    else:
        new_height, new_width = heightvg_wikipedia, width

    if LAB: 
        image_raw = color.rgb2lab(image_raw.astype(np.float32) / 255.0) / 100

    example = tf.train.Example(features=tf.train.Features(feature={
        'height': _int64_feature(int(new_height)),
        'width': _int64_feature(int(new_width)),
        'depth': _int64_feature(int(image_raw.shape[2])),
        'label': _int64_feature(int(period)),
        'id': _int64_feature(int(ix)), 
        'image_raw': _bytes_feature(image_raw.tostring())}))
    writer.write(example.SerializeToString())

def main(argv):
    random.seed(732)

    imgs = json.load(open(FLAGS.input_json, 'r'))
    exclude = json.load(open(FLAGS.exclude, 'r'))

    shuffle(imgs) #randomize order

    train_rec = os.path.join(FLAGS.directory, 'train.tfrecords')
    val_rec = os.path.join(FLAGS.directory, 'validation.tfrecords')
    test_rec = os.path.join(FLAGS.directory, 'test.tfrecords')

    writers = {}
    writers['train'] = tf.python_io.TFRecordWriter(train_rec)
    writers['val'] = tf.python_io.TFRecordWriter(val_rec)
    writers['test'] = tf.python_io.TFRecordWriter(test_rec) 

    # how many do we want of each?
    valimg = 80
    testimg = 160
    # train is remainder
    N = len(imgs)

    X = []
    y = []

    for i,img in enumerate(imgs):
        if img['no'] in exclude:
            continue 

        if img['year'] < 1886:
            img['label'] = 0
        elif img['year'] < 1888:
            img['label'] = 1
        elif img['year'] < 1890:
            img['label'] = 2
        else:
            img['label'] = 3

        X.append(img['no'])
        y.append(img['label'])

    # create splits
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=testimg, random_state=731, stratify=y)
    X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=valimg, random_state=731, stratify=y_train)

    # Count to make sure
    counts = {}
    counts['train'] = 0 
    counts['val'] = 0 
    counts['test'] = 0 

    metadata = {}
    metadata['train'] = []
    metadata['val'] = []
    metadata['test'] = []

    for i,img in enumerate(imgs):
        fn = os.path.join(FLAGS.images_root, str(img['no'])+'.jpg')

        if img['no'] in X_train:
            dset = 'train' 
        elif img['no'] in X_test:
            dset = 'test' 
        elif img['no'] in X_val:
            dset = 'val' 
        else:
            continue # in exclude list

        counts[dset] += 1

        metadata[dset].append(img)

        write_to(writers[dset],
                fn, 
                img['no'],
                img['no'],
                shortest_side=256)
        if i % 10 == 0:
            print('processing %d/%d (%.2f%% done)' % (i, N, i*100.0/N)) 
    print('train %d, val %d, test %d' % (counts['train'], counts['val'], counts['test']))
    metadata['counts'] = counts

    for w in writers.values():
        w.close()

if __name__ == '__main__':
    tf.app.run()
